(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require real.FromInt.
Require map.Map.

Parameter eqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom eqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.true) <-> (x = y).

Axiom eqb_false :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((eqb x y) = Init.Datatypes.false) <-> ~ (x = y).

Parameter neqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom neqb1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), ((neqb x y) = Init.Datatypes.true) <-> ~ (x = y).

Parameter zlt: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter zleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zlt1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zlt x y) = Init.Datatypes.true) <-> (x < y)%Z.

Axiom zleq1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((zleq x y) = Init.Datatypes.true) <-> (x <= y)%Z.

Parameter rlt:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Parameter rleq:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rlt1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rlt x y) = Init.Datatypes.true) <-> (x < y)%R.

Axiom rleq1 :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((rleq x y) = Init.Datatypes.true) <-> (x <= y)%R.

(* Why3 assumption *)
Definition real_of_int (x:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  BuiltIn.IZR x.

Axiom c_euclidian :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z), ~ (d = 0%Z) ->
  (n = (((ZArith.BinInt.Z.quot n d) * d)%Z + (ZArith.BinInt.Z.rem n d))%Z).

Axiom cmod_remainder :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((0%Z <= n)%Z -> (0%Z < d)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) < d)%Z) /\
  ((n <= 0%Z)%Z -> (0%Z < d)%Z ->
   ((-d)%Z < (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z) /\
  ((0%Z <= n)%Z -> (d < 0%Z)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) < (-d)%Z)%Z) /\
  ((n <= 0%Z)%Z -> (d < 0%Z)%Z ->
   (d < (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z).

Axiom cdiv_neutral :
  forall (a:Numbers.BinNums.Z), ((ZArith.BinInt.Z.quot a 1%Z) = a).

Axiom cdiv_inv :
  forall (a:Numbers.BinNums.Z), ~ (a = 0%Z) ->
  ((ZArith.BinInt.Z.quot a a) = 1%Z).

Axiom cdiv_closed_remainder :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= a)%Z -> (0%Z <= b)%Z ->
  (0%Z <= (b - a)%Z)%Z /\ ((b - a)%Z < n)%Z ->
  ((ZArith.BinInt.Z.rem a n) = (ZArith.BinInt.Z.rem b n)) -> (a = b).

Parameter L_power:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom L_power_def :
  forall (base:Numbers.BinNums.Z) (pow:Numbers.BinNums.Z),
  ((pow <= 0%Z)%Z -> ((L_power base pow) = 1%Z)) /\
  (~ (pow <= 0%Z)%Z ->
   ((L_power base pow) = (base * (L_power base ((-1%Z)%Z + pow)%Z))%Z)).

(* Why3 assumption *)
Definition is_bool (x:Numbers.BinNums.Z) : Prop := (x = 0%Z) \/ (x = 1%Z).

(* Why3 assumption *)
Definition is_uint8 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 256%Z)%Z.

(* Why3 assumption *)
Definition is_sint8 (x:Numbers.BinNums.Z) : Prop :=
  ((-128%Z)%Z <= x)%Z /\ (x < 128%Z)%Z.

(* Why3 assumption *)
Definition is_uint16 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 65536%Z)%Z.

(* Why3 assumption *)
Definition is_sint16 (x:Numbers.BinNums.Z) : Prop :=
  ((-32768%Z)%Z <= x)%Z /\ (x < 32768%Z)%Z.

(* Why3 assumption *)
Definition is_uint32 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 4294967296%Z)%Z.

(* Why3 assumption *)
Definition is_sint32 (x:Numbers.BinNums.Z) : Prop :=
  ((-2147483648%Z)%Z <= x)%Z /\ (x < 2147483648%Z)%Z.

(* Why3 assumption *)
Definition is_uint64 (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < 18446744073709551616%Z)%Z.

(* Why3 assumption *)
Definition is_sint64 (x:Numbers.BinNums.Z) : Prop :=
  ((-9223372036854775808%Z)%Z <= x)%Z /\ (x < 9223372036854775808%Z)%Z.

Axiom is_bool0 : is_bool 0%Z.

Axiom is_bool1 : is_bool 1%Z.

Parameter to_bool: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom to_bool'def :
  forall (x:Numbers.BinNums.Z),
  ((x = 0%Z) -> ((to_bool x) = 0%Z)) /\ (~ (x = 0%Z) -> ((to_bool x) = 1%Z)).

Parameter to_uint8: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint8: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint16: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint16: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint32: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint32: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_uint64: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint64: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter two_power_abs: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom two_power_abs_is_positive :
  forall (n:Numbers.BinNums.Z), (0%Z < (two_power_abs n))%Z.

Axiom two_power_abs_plus_pos :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  (0%Z <= m)%Z ->
  ((two_power_abs (n + m)%Z) = ((two_power_abs n) * (two_power_abs m))%Z).

Axiom two_power_abs_plus_one :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((two_power_abs (n + 1%Z)%Z) = (2%Z * (two_power_abs n))%Z).

(* Why3 assumption *)
Definition is_uint (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x < (two_power_abs n))%Z.

(* Why3 assumption *)
Definition is_sint (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) : Prop :=
  ((-(two_power_abs n))%Z <= x)%Z /\ (x < (two_power_abs n))%Z.

Parameter to_uint:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter to_sint:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom is_to_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_uint n (to_uint n x).

Axiom is_to_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_sint n (to_sint n x).

Axiom is_to_uint8 : forall (x:Numbers.BinNums.Z), is_uint8 (to_uint8 x).

Axiom is_to_sint8 : forall (x:Numbers.BinNums.Z), is_sint8 (to_sint8 x).

Axiom is_to_uint16 : forall (x:Numbers.BinNums.Z), is_uint16 (to_uint16 x).

Axiom is_to_sint16 : forall (x:Numbers.BinNums.Z), is_sint16 (to_sint16 x).

Axiom is_to_uint32 : forall (x:Numbers.BinNums.Z), is_uint32 (to_uint32 x).

Axiom is_to_sint32 : forall (x:Numbers.BinNums.Z), is_sint32 (to_sint32 x).

Axiom is_to_uint64 : forall (x:Numbers.BinNums.Z), is_uint64 (to_uint64 x).

Axiom is_to_sint64 : forall (x:Numbers.BinNums.Z), is_sint64 (to_sint64 x).

Axiom id_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  is_uint n x <-> ((to_uint n x) = x).

Axiom id_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  is_sint n x <-> ((to_sint n x) = x).

Axiom id_uint8 :
  forall (x:Numbers.BinNums.Z), is_uint8 x -> ((to_uint8 x) = x).

Axiom id_sint8 :
  forall (x:Numbers.BinNums.Z), is_sint8 x -> ((to_sint8 x) = x).

Axiom id_uint16 :
  forall (x:Numbers.BinNums.Z), is_uint16 x -> ((to_uint16 x) = x).

Axiom id_sint16 :
  forall (x:Numbers.BinNums.Z), is_sint16 x -> ((to_sint16 x) = x).

Axiom id_uint32 :
  forall (x:Numbers.BinNums.Z), is_uint32 x -> ((to_uint32 x) = x).

Axiom id_sint32 :
  forall (x:Numbers.BinNums.Z), is_sint32 x -> ((to_sint32 x) = x).

Axiom id_uint64 :
  forall (x:Numbers.BinNums.Z), is_uint64 x -> ((to_uint64 x) = x).

Axiom id_sint64 :
  forall (x:Numbers.BinNums.Z), is_sint64 x -> ((to_sint64 x) = x).

Axiom proj_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_uint n (to_uint n x)) = (to_uint n x)).

Axiom proj_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_sint n (to_sint n x)) = (to_sint n x)).

Axiom proj_uint8 :
  forall (x:Numbers.BinNums.Z), ((to_uint8 (to_uint8 x)) = (to_uint8 x)).

Axiom proj_sint8 :
  forall (x:Numbers.BinNums.Z), ((to_sint8 (to_sint8 x)) = (to_sint8 x)).

Axiom proj_uint16 :
  forall (x:Numbers.BinNums.Z), ((to_uint16 (to_uint16 x)) = (to_uint16 x)).

Axiom proj_sint16 :
  forall (x:Numbers.BinNums.Z), ((to_sint16 (to_sint16 x)) = (to_sint16 x)).

Axiom proj_uint32 :
  forall (x:Numbers.BinNums.Z), ((to_uint32 (to_uint32 x)) = (to_uint32 x)).

Axiom proj_sint32 :
  forall (x:Numbers.BinNums.Z), ((to_sint32 (to_sint32 x)) = (to_sint32 x)).

Axiom proj_uint64 :
  forall (x:Numbers.BinNums.Z), ((to_uint64 (to_uint64 x)) = (to_uint64 x)).

Axiom proj_sint64 :
  forall (x:Numbers.BinNums.Z), ((to_sint64 (to_sint64 x)) = (to_sint64 x)).

Axiom proj_su :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((to_sint n (to_uint n x)) = (to_uint n x)).

Axiom incl_su :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_uint n x ->
  is_sint n x.

Axiom proj_su_uint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_sint (m + n)%Z (to_uint n x)) = (to_uint n x)).

Axiom proj_su_sint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_sint n (to_uint (m + (n + 1%Z)%Z)%Z x)) = (to_sint n x)).

Axiom proj_int8 :
  forall (x:Numbers.BinNums.Z), ((to_sint8 (to_uint8 x)) = (to_sint8 x)).

Axiom proj_int16 :
  forall (x:Numbers.BinNums.Z), ((to_sint16 (to_uint16 x)) = (to_sint16 x)).

Axiom proj_int32 :
  forall (x:Numbers.BinNums.Z), ((to_sint32 (to_uint32 x)) = (to_sint32 x)).

Axiom proj_int64 :
  forall (x:Numbers.BinNums.Z), ((to_sint64 (to_uint64 x)) = (to_sint64 x)).

Axiom proj_us_uint :
  forall (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((to_uint (n + 1%Z)%Z (to_sint (m + n)%Z x)) = (to_uint (n + 1%Z)%Z x)).

Axiom incl_uint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_uint n x -> is_uint (n + i)%Z x.

Axiom incl_sint :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_sint n x -> is_sint (n + i)%Z x.

Axiom incl_int :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= i)%Z -> is_uint n x -> is_sint (n + i)%Z x.

Parameter bit_testb:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter bit_test: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Prop.

Parameter lnot: Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter land: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter lxor: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter lor: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter lsl: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Parameter lsr: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom lnot_bool : ((lnot 0%Z) = (-1%Z)%Z) /\ ((lnot (-1%Z)%Z) = 0%Z).

Axiom land_idemp : forall (x:Numbers.BinNums.Z), ((land x x) = x).

Axiom land_0 : forall (x:Numbers.BinNums.Z), ((land 0%Z x) = 0%Z).

Axiom land_0bis : forall (x:Numbers.BinNums.Z), ((land x 0%Z) = 0%Z).

Axiom land_1 : forall (x:Numbers.BinNums.Z), ((land (-1%Z)%Z x) = x).

Axiom land_1bis : forall (x:Numbers.BinNums.Z), ((land x (-1%Z)%Z) = x).

Axiom land_bool :
  ((land 0%Z 0%Z) = 0%Z) /\
  ((land 0%Z 1%Z) = 0%Z) /\ ((land 1%Z 0%Z) = 0%Z) /\ ((land 1%Z 1%Z) = 1%Z).

Axiom lor_idemp : forall (x:Numbers.BinNums.Z), ((lor x x) = x).

Axiom lor_1 : forall (x:Numbers.BinNums.Z), ((lor (-1%Z)%Z x) = (-1%Z)%Z).

Axiom lor_1bis : forall (x:Numbers.BinNums.Z), ((lor x (-1%Z)%Z) = (-1%Z)%Z).

Axiom lor_0 : forall (x:Numbers.BinNums.Z), ((lor 0%Z x) = x).

Axiom lor_0bis : forall (x:Numbers.BinNums.Z), ((lor x 0%Z) = x).

Axiom lor_bool :
  ((lor 0%Z 0%Z) = 0%Z) /\
  ((lor 0%Z 1%Z) = 1%Z) /\ ((lor 1%Z 0%Z) = 1%Z) /\ ((lor 1%Z 1%Z) = 1%Z).

Axiom lxor_nilpotent : forall (x:Numbers.BinNums.Z), ((lxor x x) = 0%Z).

Axiom lxor_1 : forall (x:Numbers.BinNums.Z), ((lxor (-1%Z)%Z x) = (lnot x)).

Axiom lxor_1bis :
  forall (x:Numbers.BinNums.Z), ((lxor x (-1%Z)%Z) = (lnot x)).

Axiom lxor_0 : forall (x:Numbers.BinNums.Z), ((lxor 0%Z x) = x).

Axiom lxor_0bis : forall (x:Numbers.BinNums.Z), ((lxor x 0%Z) = x).

Axiom lxor_bool :
  ((lxor 0%Z 0%Z) = 0%Z) /\
  ((lxor 0%Z 1%Z) = 1%Z) /\ ((lxor 1%Z 0%Z) = 1%Z) /\ ((lxor 1%Z 1%Z) = 0%Z).

Axiom lsl_0 : forall (x:Numbers.BinNums.Z), ((lsl x 0%Z) = x).

Axiom lsl_1 : forall (x:Numbers.BinNums.Z), ((lsl x 1%Z) = (2%Z * x)%Z).

Axiom lsl_add :
  forall (x:Numbers.BinNums.Z) (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z),
  (0%Z <= p)%Z -> (0%Z <= q)%Z -> ((lsl (lsl x p) q) = (lsl x (p + q)%Z)).

Axiom lsr_0 : forall (x:Numbers.BinNums.Z), ((lsr x 0%Z) = x).

Axiom lsr_1 :
  forall (x:Numbers.BinNums.Z), (0%Z <= x)%Z ->
  ((lsr x 1%Z) = (ZArith.BinInt.Z.quot x 2%Z)).

Axiom lsr_add :
  forall (x:Numbers.BinNums.Z) (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z),
  (0%Z <= p)%Z -> (0%Z <= q)%Z -> ((lsr (lsr x p) q) = (lsr x (p + q)%Z)).

Axiom lsl_lsr_add :
  forall (x:Numbers.BinNums.Z) (p:Numbers.BinNums.Z) (q:Numbers.BinNums.Z),
  (0%Z <= q)%Z /\ (q <= p)%Z -> ((lsr (lsl x p) q) = (lsl x (p - q)%Z)).

Axiom bit_test_def :
  forall (x:Numbers.BinNums.Z) (k:Numbers.BinNums.Z),
  ((bit_testb x k) = Init.Datatypes.true) <-> bit_test x k.

Axiom bit_test_extraction :
  forall (x:Numbers.BinNums.Z) (k:Numbers.BinNums.Z), (0%Z <= k)%Z ->
  ~ ((land x (lsl 1%Z k)) = 0%Z) <-> bit_test x k.

Axiom bit_test_extraction_eq :
  forall (x:Numbers.BinNums.Z) (k:Numbers.BinNums.Z), (0%Z <= k)%Z ->
  ((land x (lsl 1%Z k)) = (lsl 1%Z k)) <-> bit_test x k.

Axiom lsl_1_0 : ((lsl 1%Z 0%Z) = 1%Z).

Axiom bit_test_extraction_bis :
  forall (x:Numbers.BinNums.Z), ~ ((land 1%Z x) = 0%Z) -> bit_test x 0%Z.

Axiom bit_test_extraction_bis_eq :
  forall (x:Numbers.BinNums.Z), bit_test x 0%Z -> ((land 1%Z x) = 1%Z).

Axiom lnot_extraction_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (0%Z <= i)%Z ->
  ((bit_testb (lnot x) i) = (Init.Datatypes.negb (bit_testb x i))).

Axiom lnot_extraction :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (0%Z <= i)%Z ->
  bit_test (lnot x) i <-> ~ bit_test x i.

Axiom land_extraction_bool :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z ->
  ((bit_testb (land x y) i) =
   (Init.Datatypes.andb (bit_testb x i) (bit_testb y i))).

Axiom land_extraction :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z -> bit_test (land x y) i <-> bit_test x i /\ bit_test y i.

Axiom lor_extraction_bool :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z ->
  ((bit_testb (lor x y) i) =
   (Init.Datatypes.orb (bit_testb x i) (bit_testb y i))).

Axiom lor_extraction :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z -> bit_test (lor x y) i <-> bit_test x i \/ bit_test y i.

Axiom lxor_extraction_bool :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z ->
  ((bit_testb (lxor x y) i) =
   (Init.Datatypes.xorb (bit_testb x i) (bit_testb y i))).

Axiom lxor_extraction :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z -> bit_test (lxor x y) i <-> (bit_test x i <-> ~ bit_test y i).

Axiom lsl_1_two_power :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((lsl 1%Z n) = (two_power_abs n)).

Axiom land_1_lsl_1 :
  forall (a:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (a < (lsl 1%Z n))%Z ->
  (((2%Z * a)%Z + (land 1%Z x))%Z < (lsl 1%Z (1%Z + n)%Z))%Z.

Axiom lsl_extraction_sup_bool :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z -> (n <= m)%Z ->
  ((bit_testb (lsl x n) m) = (bit_testb x (m - n)%Z)).

Axiom lsl_extraction_sup :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z -> (n <= m)%Z ->
  bit_test (lsl x n) m <-> bit_test x (m - n)%Z.

Axiom lsl_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z -> (m < n)%Z ->
  ((bit_testb (lsl x n) m) = Init.Datatypes.false).

Axiom lsl_extraction_inf :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z -> (m < n)%Z -> ~ bit_test (lsl x n) m.

Axiom lsr_extraction_bool :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  ((bit_testb (lsr x n) m) = (bit_testb x (m + n)%Z)).

Axiom lsr_extractionl :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (m:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> (0%Z <= m)%Z ->
  bit_test (lsr x n) m <-> bit_test x (m + n)%Z.

Axiom lsl1_extraction_bool :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z), (0%Z <= i)%Z ->
  (0%Z <= j)%Z -> ((bit_testb (lsl 1%Z i) j) = (eqb i j)).

Axiom lsl1_extraction :
  forall (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z), (0%Z <= i)%Z ->
  (0%Z <= j)%Z -> bit_test (lsl 1%Z i) j <-> (i = j).

Axiom pos_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> (0%Z <= i)%Z -> (x < (lsl 1%Z i))%Z -> (i <= j)%Z ->
  ~ bit_test x j.

Axiom pos_extraction_sup_inv :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (0%Z <= i)%Z ->
  (forall (j:Numbers.BinNums.Z), (i <= j)%Z -> ~ bit_test x j) ->
  (0%Z <= x)%Z /\ (x < (lsl 1%Z i))%Z.

Axiom to_uint_extraction_sup :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z /\ (n <= i)%Z -> is_uint n x -> ~ bit_test x i.

Axiom to_uint_extraction_inf_bool :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < n)%Z ->
  ((bit_testb (to_uint n x) i) = (bit_testb x i)).

Axiom to_uint_extraction_inf :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < n)%Z -> bit_test (to_uint n x) i <-> bit_test x i.

Axiom is_uint_ext :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> is_uint n x -> is_uint n y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_uint8_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (8%Z <= i)%Z ->
  is_uint8 x -> ~ bit_test x i.

Axiom to_uint8_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 8%Z)%Z ->
  ((bit_testb (to_uint8 x) i) = (bit_testb x i)).

Axiom to_uint8_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 8%Z)%Z -> bit_test (to_uint8 x) i <-> bit_test x i.

Axiom is_uint8_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint8 x ->
  is_uint8 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 8%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_uint16_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (16%Z <= i)%Z ->
  is_uint16 x -> ~ bit_test x i.

Axiom to_uint16_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 16%Z)%Z ->
  ((bit_testb (to_uint16 x) i) = (bit_testb x i)).

Axiom to_uint16_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 16%Z)%Z -> bit_test (to_uint16 x) i <-> bit_test x i.

Axiom is_uint16_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint16 x ->
  is_uint16 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 16%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_uint32_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (32%Z <= i)%Z ->
  is_uint32 x -> ~ bit_test x i.

Axiom to_uint32_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 32%Z)%Z ->
  ((bit_testb (to_uint32 x) i) = (bit_testb x i)).

Axiom to_uint32_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 32%Z)%Z -> bit_test (to_uint32 x) i <-> bit_test x i.

Axiom is_uint32_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint32 x ->
  is_uint32 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 32%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_uint64_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (64%Z <= i)%Z ->
  is_uint64 x -> ~ bit_test x i.

Axiom to_uint64_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 64%Z)%Z ->
  ((bit_testb (to_uint64 x) i) = (bit_testb x i)).

Axiom to_uint64_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 64%Z)%Z -> bit_test (to_uint64 x) i <-> bit_test x i.

Axiom is_uint64_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint64 x ->
  is_uint64 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < 64%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_sint_extraction_sup :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= n)%Z /\ (n <= i)%Z -> is_sint n x -> bit_test x i <-> (x < 0%Z)%Z.

Axiom to_sint_extraction_inf_bool :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < n)%Z ->
  ((bit_testb (to_sint n x) i) = (bit_testb x i)).

Axiom to_sint_extraction_inf :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < n)%Z -> bit_test (to_sint n x) i <-> bit_test x i.

Axiom is_sint_ext :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> is_sint n x -> is_sint n y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i <= n)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_sint8_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (7%Z <= i)%Z ->
  is_sint8 x -> bit_test x i <-> (x < 0%Z)%Z.

Axiom to_sint8_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 7%Z)%Z ->
  ((bit_testb (to_sint8 x) i) = (bit_testb x i)).

Axiom to_sint8_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 7%Z)%Z -> bit_test (to_sint8 x) i <-> bit_test x i.

Axiom is_sint8_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint8 x ->
  is_sint8 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i <= 7%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_sint16_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (15%Z <= i)%Z ->
  is_sint16 x -> bit_test x i <-> (x < 0%Z)%Z.

Axiom to_sint16_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 15%Z)%Z ->
  ((bit_testb (to_sint16 x) i) = (bit_testb x i)).

Axiom to_sint16_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 15%Z)%Z -> bit_test (to_sint16 x) i <-> bit_test x i.

Axiom is_sint16_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint16 x ->
  is_sint16 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i <= 15%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_sint32_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (31%Z <= i)%Z ->
  is_sint32 x -> bit_test x i <-> (x < 0%Z)%Z.

Axiom to_sint32_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 31%Z)%Z ->
  ((bit_testb (to_sint32 x) i) = (bit_testb x i)).

Axiom to_sint32_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 31%Z)%Z -> bit_test (to_sint32 x) i <-> bit_test x i.

Axiom is_sint32_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint32 x ->
  is_sint32 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i <= 31%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_sint64_extraction_sup :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z), (63%Z <= i)%Z ->
  is_sint64 x -> bit_test x i <-> (x < 0%Z)%Z.

Axiom to_sint64_extraction_inf_bool :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 63%Z)%Z ->
  ((bit_testb (to_sint64 x) i) = (bit_testb x i)).

Axiom to_sint64_extraction_inf :
  forall (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < 63%Z)%Z -> bit_test (to_sint64 x) i <-> bit_test x i.

Axiom is_sint64_ext :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint64 x ->
  is_sint64 y ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i <= 63%Z)%Z ->
   bit_test x i <-> bit_test y i) ->
  (x = y).

Axiom to_uint_lor :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((to_uint n (lor x y)) = (lor (to_uint n x) (to_uint n y))).

Axiom to_uint8_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((to_uint8 (lor x y)) = (lor (to_uint8 x) (to_uint 8%Z y))).

Axiom to_uint16_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((to_uint16 (lor x y)) = (lor (to_uint16 x) (to_uint16 y))).

Axiom to_uint32_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((to_uint32 (lor x y)) = (lor (to_uint32 x) (to_uint32 y))).

Axiom to_uint64_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((to_uint64 (lor x y)) = (lor (to_uint64 x) (to_uint64 y))).

Axiom is_uint_lxor :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_uint n x -> is_uint n y -> ((to_uint n (lxor x y)) = (lxor x y)).

Axiom is_uint_lor :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_uint n x -> is_uint n y -> ((to_uint n (lor x y)) = (lor x y)).

Axiom is_uint_land :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_uint n x -> is_uint n y -> ((to_uint n (land x y)) = (land x y)).

Axiom is_uint_lsr :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= y)%Z -> is_uint n x -> ((to_uint n (lsr x y)) = (lsr x y)).

Axiom is_uint_lsl1_inf :
  forall (n:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= y)%Z /\ (y < n)%Z -> ((to_uint n (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_uint_lsl1_sup :
  forall (n:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= n)%Z /\ (n <= y)%Z -> ((to_uint n (lsl 1%Z y)) = 0%Z).

Axiom is_uint8_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint8 x ->
  is_uint8 y -> ((to_uint8 (lxor x y)) = (lxor x y)).

Axiom is_uint8_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint8 x ->
  is_uint8 y -> ((to_uint8 (lor x y)) = (lor x y)).

Axiom is_uint8_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint8 x ->
  is_uint8 y -> ((to_uint8 (land x y)) = (land x y)).

Axiom is_uint8_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_uint8 x -> ((to_uint8 (lsr x y)) = (lsr x y)).

Axiom is_uint8_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 8%Z)%Z ->
  ((to_uint8 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_uint8_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (8%Z <= y)%Z ->
  ((to_uint8 (lsl 1%Z y)) = 0%Z).

Axiom is_uint16_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint16 x ->
  is_uint16 y -> ((to_uint16 (lxor x y)) = (lxor x y)).

Axiom is_uint16_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint16 x ->
  is_uint16 y -> ((to_uint16 (lor x y)) = (lor x y)).

Axiom is_uint16_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint16 x ->
  is_uint16 y -> ((to_uint16 (land x y)) = (land x y)).

Axiom is_uint16_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_uint16 x -> ((to_uint16 (lsr x y)) = (lsr x y)).

Axiom is_uint16_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 16%Z)%Z ->
  ((to_uint16 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_uint16_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (16%Z <= y)%Z ->
  ((to_uint16 (lsl 1%Z y)) = 0%Z).

Axiom is_uint32_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint32 x ->
  is_uint32 y -> ((to_uint32 (lxor x y)) = (lxor x y)).

Axiom is_uint32_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint32 x ->
  is_uint32 y -> ((to_uint32 (lor x y)) = (lor x y)).

Axiom is_uint32_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint32 x ->
  is_uint32 y -> ((to_uint32 (land x y)) = (land x y)).

Axiom is_uint32_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_uint32 x -> ((to_uint32 (lsr x y)) = (lsr x y)).

Axiom is_uint32_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 32%Z)%Z ->
  ((to_uint32 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_uint32_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (32%Z <= y)%Z ->
  ((to_uint32 (lsl 1%Z y)) = 0%Z).

Axiom is_uint64_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint64 x ->
  is_uint64 y -> ((to_uint64 (lxor x y)) = (lxor x y)).

Axiom is_uint64_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint64 x ->
  is_uint64 y -> ((to_uint64 (lor x y)) = (lor x y)).

Axiom is_uint64_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_uint64 x ->
  is_uint64 y -> ((to_uint64 (land x y)) = (land x y)).

Axiom is_uint64_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_uint64 x -> ((to_uint64 (lsr x y)) = (lsr x y)).

Axiom is_uint64_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 64%Z)%Z ->
  ((to_uint64 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_uint64_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (64%Z <= y)%Z ->
  ((to_uint64 (lsl 1%Z y)) = 0%Z).

Axiom is_sint_lnot :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z), is_sint n x ->
  ((to_sint n (lnot x)) = (lnot x)).

Axiom is_sint_lxor :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_sint n x -> is_sint n y -> ((to_sint n (lxor x y)) = (lxor x y)).

Axiom is_sint_lor :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_sint n x -> is_sint n y -> ((to_sint n (lor x y)) = (lor x y)).

Axiom is_sint_land :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_sint n x -> is_sint n y -> ((to_sint n (land x y)) = (land x y)).

Axiom is_sint_lsr :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= y)%Z -> is_sint n x -> ((to_sint n (lsr x y)) = (lsr x y)).

Axiom is_sint_lsl1_inf :
  forall (n:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= y)%Z /\ (y < n)%Z -> ((to_sint n (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_sint_lsl1_sup :
  forall (n:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  (0%Z <= n)%Z /\ (n < y)%Z -> ((to_sint n (lsl 1%Z y)) = 0%Z).

Axiom is_sint8_lnot :
  forall (x:Numbers.BinNums.Z), is_sint8 x ->
  ((to_sint8 (lnot x)) = (lnot x)).

Axiom is_sint8_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint8 x ->
  is_sint8 y -> ((to_sint8 (lxor x y)) = (lxor x y)).

Axiom is_sint8_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint8 x ->
  is_sint8 y -> ((to_sint8 (lor x y)) = (lor x y)).

Axiom is_sint8_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint8 x ->
  is_sint8 y -> ((to_sint8 (land x y)) = (land x y)).

Axiom is_sint8_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_sint8 x -> ((to_sint8 (lsr x y)) = (lsr x y)).

Axiom is_sint8_lsl1 : ((lsl 1%Z 7%Z) = 128%Z).

Axiom is_sint8_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 7%Z)%Z ->
  ((to_sint8 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_sint8_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (8%Z <= y)%Z ->
  ((to_sint8 (lsl 1%Z y)) = 0%Z).

Axiom is_sint16_lnot :
  forall (x:Numbers.BinNums.Z), is_sint16 x ->
  ((to_sint16 (lnot x)) = (lnot x)).

Axiom is_sint16_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint16 x ->
  is_sint16 y -> ((to_sint16 (lxor x y)) = (lxor x y)).

Axiom is_sint16_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint16 x ->
  is_sint16 y -> ((to_sint16 (lor x y)) = (lor x y)).

Axiom is_sint16_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint16 x ->
  is_sint16 y -> ((to_sint16 (land x y)) = (land x y)).

Axiom is_sint16_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_sint16 x -> ((to_sint16 (lsr x y)) = (lsr x y)).

Axiom is_sint16_lsl1 : ((lsl 1%Z 15%Z) = 32768%Z).

Axiom is_sint16_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 15%Z)%Z ->
  ((to_sint16 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_sint16_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (16%Z <= y)%Z ->
  ((to_sint16 (lsl 1%Z y)) = 0%Z).

Axiom is_sint32_lnot :
  forall (x:Numbers.BinNums.Z), is_sint32 x ->
  ((to_sint32 (lnot x)) = (lnot x)).

Axiom is_sint32_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint32 x ->
  is_sint32 y -> ((to_sint32 (lxor x y)) = (lxor x y)).

Axiom is_sint32_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint32 x ->
  is_sint32 y -> ((to_sint32 (lor x y)) = (lor x y)).

Axiom is_sint32_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint32 x ->
  is_sint32 y -> ((to_sint32 (land x y)) = (land x y)).

Axiom is_sint32_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_sint32 x -> ((to_sint32 (lsr x y)) = (lsr x y)).

Axiom is_sint32_lsl1 : ((lsl 1%Z 31%Z) = 2147483648%Z).

Axiom is_sint32_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 31%Z)%Z ->
  ((to_sint32 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_sint32_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (32%Z <= y)%Z ->
  ((to_sint32 (lsl 1%Z y)) = 0%Z).

Axiom is_sint64_lnot :
  forall (x:Numbers.BinNums.Z), is_sint64 x ->
  ((to_sint64 (lnot x)) = (lnot x)).

Axiom is_sint64_lxor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint64 x ->
  is_sint64 y -> ((to_sint64 (lxor x y)) = (lxor x y)).

Axiom is_sint64_lor :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint64 x ->
  is_sint64 y -> ((to_sint64 (lor x y)) = (lor x y)).

Axiom is_sint64_land :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), is_sint64 x ->
  is_sint64 y -> ((to_sint64 (land x y)) = (land x y)).

Axiom is_sint64_lsr :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= y)%Z ->
  is_sint64 x -> ((to_sint64 (lsr x y)) = (lsr x y)).

Axiom is_sint64_lsl1 : ((lsl 1%Z 63%Z) = 9223372036854775808%Z).

Axiom is_sint64_lsl1_inf :
  forall (y:Numbers.BinNums.Z), (0%Z <= y)%Z /\ (y < 63%Z)%Z ->
  ((to_sint64 (lsl 1%Z y)) = (lsl 1%Z y)).

Axiom is_sint64_lsl1_sup :
  forall (y:Numbers.BinNums.Z), (64%Z <= y)%Z ->
  ((to_sint64 (lsl 1%Z y)) = 0%Z).

Axiom uint_land_range :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (0%Z <= x)%Z ->
  (0%Z <= (land x y))%Z /\ ((land x y) <= x)%Z.

Axiom uint_lor_inf :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), ((-1%Z)%Z <= x)%Z ->
  (0%Z <= y)%Z -> (x <= (lor x y))%Z.

Axiom sint_land_inf :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (x <= 0%Z)%Z ->
  (y < 0%Z)%Z -> ((land x y) <= x)%Z.

Axiom sint_lor_range :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), (x < 0%Z)%Z ->
  (x <= (lor x y))%Z /\ ((lor x y) < 0%Z)%Z.

Axiom is_uint_lor_distrib :
  forall (n:Numbers.BinNums.Z) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  is_uint n (lor x y) <-> is_uint n x /\ is_uint n y.

Axiom lor_addition :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), ((land x y) = 0%Z) ->
  ((x + y)%Z = (lor x y)).

Axiom lxor_addition :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z), ((land x y) = 0%Z) ->
  ((x + y)%Z = (lxor x y)).

Axiom to_uint_land_edge :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z), (0%Z <= n)%Z ->
  ((to_uint n x) = (land ((lsl 1%Z n) - 1%Z)%Z x)).

Axiom Q_two_power_x_is_one_shift_x :
  forall (x:Numbers.BinNums.Z), (0%Z <= x)%Z ->
  ((L_power 2%Z x) = (lsl 1%Z x)).

(* Why3 goal *)
Theorem wp_goal :
  forall (i:Numbers.BinNums.Z) (i1:Numbers.BinNums.Z), (0%Z <= i1)%Z ->
  (0%Z <= i)%Z ->
  ((ZArith.BinInt.Z.rem i (L_power 2%Z i1)) = (lsr (lsl i i1) i1)).
Proof.
intros i i1 h1 h2.

Qed.

